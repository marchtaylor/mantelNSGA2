---
title: "mantelNSGA2 vignette"
output:
  rmarkdown::html_vignette:
  # rmarkdown::pdf_document:
    fig_caption: yes
    number_sections: true
    df_print: kable
vignette: >
  %\VignetteIndexEntry{mantelNSGA2_vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: mantelNSGA2.bib
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  echo = TRUE, 
  collapse = TRUE,
  comment = "#>",
  fig.width = 6, fig.height = 5
)
```

```{r setup, warning=FALSE, message=FALSE}
library(mantelNSGA2)
library(vegan)
data("varechem")
data("varespec")
```

# Introduction

The **mantelNSGA2** package was created to facilitate the efficient search of explanatory variables for use in a BIOENV-like analysis [@clarke_method_1993]. BIOENV explores the correlation between two multivariate data sets via a [Mantel test](https://en.wikipedia.org/wiki/Mantel_test) according to pairwise similarity (or distance) values between samples. One of the data sets is *fixed*, i.e. all variables are includes in the similarity matrix, while all combinations of the other data set's variables are *varied* to try and identify subsets of best correlating ones. Correlations may be based either on Pearson or Spearman correlations, with the latter being preferred in community analysis due to it's non-parametric nature. Likewise, choice of similarity metrics may also be important in non-parametric situations (e.g. Bray-Curtis).

The vegan package's \code{\link[vegan]{bioenv}} function assumes BIOENV setup, and the similarity matrix of environmental data is assumed to be based on normalized "euclidean" distances. This makes sense with environmental data where one normalizes the data to remove the effect of differing units between parameters, yet in cases where the variable matrix is biological, one might want more flexibility (a Bray-Curtis measure of similarity is common given its non-parametric nature). For example, beyond the typical biological to environmental comparison (BIOENV setup), one can also use the routine to explore other other types of relationships; e.g.:

-   ENVBIO: subset of biological variables that best correlate to the overall environmental pattern
-   BIOBIO: subset of biological variables that best correlate to the overall biological pattern
-   ENVENV: subset of environmental variables that best correlate to the overall environmental pattern

It is important to mention that one of the reasons why a variable biological similarity matrix is often less explored with the routine is that the number of possible subset combinations becomes computationally overwhelming when the number of species/groups is large - the total number of combinations being equal to 2\^n - 1, where n is the total number of variables. For this reason, Clarke and Warwick (1998) presented a stepwise routine (BVSTEP) (see \code{\link[mantelNSGA2]{bvStep}} for more efficient exploration of the subset combinations).

which typically contains environmental variables (*ENV*), against that of the o and evaluate which subset of variables produced the highest correlation with a fixed. The non-parametric nature of biom

The BIOENV approach typically focuses on used to evaluate whether a subset of environmental variables

The typical setup for BIOENV is to explore subsets of environmental variables that best correlate to sample similarities of the biological community (e.g. species biomass or abundance), called "BIOENV". In this case, the similarity matrix of the community is fixed, while subsets of the environmental variables are used in the calculation of the environmental similarity matrix. A correlation coefficient (typically Spearman rank correlation coefficient, "rho") is then calculated between the two matrices and the best subset of environmental variables can then be identified and further subjected to a permutation test to determine significance.

bla [@clarke_approach_1994]. @clarke_approach_1994 total combinations tested by sinkr::bioEnv()

`r paste("2^44-1", "=", sprintf("%.2e", 2^ncol(varespec)-1))`

# Under construction...

```{r}
# chance of having few or many "genes" turned on is low, so one ends up
# mainly exploring the middle
nvar <- 20
tmp <- replicate(1000, expr = sum(sample(x = c(0,1), nvar, replace = TRUE)))
hist(tmp, breaks = seq(0, nvar))

# more extreme when number of genes is high
nvar <- 100
tmp <- replicate(1000, expr = sum(sample(x = c(0,1), nvar, replace = TRUE)))
hist(tmp, breaks = seq(0, nvar))

```

## ENVBIO example

```{r envbio_nsga2, message=FALSE}
# biological community variables that best correlate with environmental data
fix.mat = varechem
var.mat = wisconsin(varespec)
fix.dist.method = "euclidean"
var.dist.method = "bray"
scale.fix = TRUE
scale.var = FALSE
p.feat <- 0.1

# mantelNSGA2
set.seed(1111)
fitGA <- mantelNSGA2(
  fix.mat = fix.mat, var.mat = var.mat,
  fix.dist.method = fix.dist.method, var.dist.method = var.dist.method,
  scale.fix = scale.fix, scale.var = scale.var, p.feat = p.feat,
  pop.size = 50, max.iter = 100, stop.criterion = 50,
  mutation.rate = 0.2, crossover.rate = 0.8, verbose = FALSE
)
# plot(fitGA$generation.fitness)
# fitGA$pareto.solution
plot(fitGA, parFrontT = "o")

```

```{r envbio_nsga2_vs_bvstep, warning=FALSE}
# Compare to bvStep
set.seed(1111)
fitBV <- bvStep(
  fix.mat = fix.mat, var.mat = var.mat,
  fix.dist.method = fix.dist.method, var.dist.method = var.dist.method,
  scale.fix = scale.fix, scale.var = scale.var,
  num.restarts = 50, 
  random.selection = TRUE,
  prop.selected.var = 0.4, 
  verbose = FALSE
)
# fitBV$order.by.best # mantelGA not looking in simpler solutions enough
# fitBV$order.by.i.comb
plot(fitGA, parFrontT = "o")
points(-fitBV$order.by.i.comb$rho, fitBV$order.by.i.comb$n.var/ncol(var.mat), pch = 1, col = 4, t = "o")
```

## BIOBIO example

```{r biobio_nsga2, message=FALSE}
# biological community variables that best correlate with the
# overall biological community
fix.mat = wisconsin(varespec)
var.mat = wisconsin(varespec)
fix.dist.method = "bray"
var.dist.method = "bray"
scale.fix = FALSE
scale.var = FALSE
p.feat <- 0.1

# mantelNSGA2
set.seed(1111)
fitGA2 <- mantelNSGA2(
  fix.mat = fix.mat, var.mat = var.mat,
  fix.dist.method = fix.dist.method, var.dist.method = var.dist.method,
  scale.fix = scale.fix, scale.var = scale.var, p.feat = p.feat,
  pop.size = 50, max.iter = 100, stop.criterion = 50,
  mutation.rate = 0.2, crossover.rate = 0.8, verbose = FALSE
)
# plot(fitGA2$generation.fitness)
# fitGA2$pareto.solution
plot(fitGA2, parFrontT = "o")

```

```{r biobio_nsga2_vs_bvstep, warning=FALSE}
# Compare to bvStep
set.seed(1111)
fitBV2 <- bvStep(
  fix.mat = fix.mat, var.mat = var.mat,
  fix.dist.method = fix.dist.method, var.dist.method = var.dist.method,
  scale.fix = scale.fix, scale.var = scale.var,
  num.restarts = 50, 
  random.selection = TRUE,
  prop.selected.var = 0.3, 
  var.always.include = c(15,23,26), 
  verbose = FALSE
)
# fitBV2$order.by.best # mantelGA not looking in simpler solutions enough
# fitBV2$order.by.i.comb
plot(fitGA2, parFrontT = "o")
points(-fitBV2$order.by.i.comb$rho, fitBV2$order.by.i.comb$n.var/ncol(var.mat), pch = 1, col = 4, t = "o")
```

# References
