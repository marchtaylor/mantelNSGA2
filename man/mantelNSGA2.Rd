% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mantelNSGA2.R
\name{mantelNSGA2}
\alias{mantelNSGA2}
\title{Mantel test permutation search with NSGA2 (Non-dominated
  sorting genetic algorithm)}
\usage{
mantelNSGA2(
  fix.mat,
  var.mat,
  fix.dist.method = "bray",
  var.dist.method = "euclidean",
  scale.fix = FALSE,
  scale.var = TRUE,
  pop.size = 100,
  offspring.size = NULL,
  crossover.rate = 0.8,
  mutation.rate = 0.1,
  max.iter = 150,
  allowZeroGenes = FALSE,
  remove.overlap = TRUE,
  p.feat = 1,
  stop.criterion = NULL,
  memoisation = TRUE,
  ref.point = c(0, 1)
)
}
\arguments{
\item{fix.mat}{The "fixed" matrix of community or environmental sample by variable values}

\item{var.mat}{A "variable" matrix of community or environmental sample by variable values}

\item{fix.dist.method}{The method of calculating dissimilarity indices between samples in the fixed
matrix (Uses the \code{\link[vegan]{vegdist}} function from the vegan package to calculate distance matrices. See
the documentation for available methods.). Defaults to Bray-Curtis dissimilarity \code{"bray"}.}

\item{var.dist.method}{The method of calculating dissimilarity indices between samples in the variable
matrix. Defaults to Euclidean dissimilarity \code{"euclidean"}.}

\item{scale.fix}{Logical. Should fixed matrix be centered and scaled (Defaults to \code{FALSE},
recommended for biologic data).}

\item{scale.var}{Logical. Should fixed matrix be centered and scaled (Defaults to \code{TRUE},
recommended for environmental data to correct for differing units between variables).}

\item{pop.size}{Parent population size for the genetic algorithm.}

\item{offspring.size}{Offspring population size for the genetic algorithm.}

\item{crossover.rate}{Fraction of crossover between parent solutions.}

\item{mutation.rate}{Probability of a mutation (bitflip) within the feature vector.}

\item{max.iter}{Maximum number of iterations the algorithm should run.}

\item{allowZeroGenes}{Logical. If individuals containing only zeros
(no features) should be included in the search (\code{TRUE}) or not (\code{FALSE}).}

\item{remove.overlap}{Logical. If overlapping solutions should be removed (see Nojima et al. 2005)?}

\item{p.feat}{Numeric. Value between 0-1 (but non-zero), indicating the maximum proportion
of explanatory variables to turn on (i.e. genes) in individuals of the
initial population. A lower value will assist in the search of simpler
models in the earlier generations of the search.}

\item{stop.criterion}{Numeric. Maximum number of iterations without improvement
of the solution.}

\item{memoisation}{Logical. If memoisation should be
used (\code{TRUE}) or not (\code{FALSE}). If memoisation is used,
function calls with the same input paramet}

\item{ref.point}{Vector of length 2, defining the Reference point for the
Hypervolume Indicator.}
}
\value{

}
\description{
Mantel test permutation search with NSGA2 (Non-dominated
  sorting genetic algorithm)
}
\examples{

library(vegan)
data("varechem")
data("varespec")

# chance of having few or many "genes" turned on is low, so one ends up
# mainly exploring the middle
nvar <- 20
tmp <- replicate(1000, expr = sum(sample(x = c(0,1), nvar, replace = TRUE)))
hist(tmp, breaks = seq(0, nvar))

# more extreme when number of genes is high
nvar <- 100
tmp <- replicate(1000, expr = sum(sample(x = c(0,1), nvar, replace = TRUE)))
hist(tmp, breaks = seq(0, nvar))

# consequence is that one needs to simulate for a long time to eventually
# explore tail regions. Or, starting population should start with a smaller
# number of genes turned on


### envbio
# biological community variables that best correlate with environmental data
fix.mat = varechem
var.mat = wisconsin(varespec)
fix.dist.method = "euclidean"
var.dist.method = "bray"
scale.fix = TRUE
scale.var = FALSE
p.feat <- 0.1
2^ncol(var.mat)-1 # total combinations tested by bioEnv()

# mantelNSGA2
set.seed(1111)
fitGA <- mantelNSGA2(
  fix.mat = fix.mat, var.mat = var.mat,
  fix.dist.method = fix.dist.method, var.dist.method = var.dist.method,
  scale.fix = scale.fix, scale.var = scale.var, p.feat = p.feat,
  pop.size = 50, max.iter = 100, stop.criterion = 50,
  mutation.rate = 0.2, crossover.rate = 0.8
)
plot(fitGA$generation.fitness)
fitGA$pareto.solution
plot(fitGA, parFrontT = "o")


# Compare to bvStep
set.seed(1111)
fitBV <- bvStep(
  fix.mat = fix.mat, var.mat = var.mat,
  fix.dist.method = fix.dist.method, var.dist.method = var.dist.method,
  scale.fix = scale.fix, scale.var = scale.var,
  num.restarts = 50,
  random.selection = TRUE,
  prop.selected.var = 0.4
)
fitBV$order.by.best # mantelGA not looking in simpler solutions enough
fitBV$order.by.i.comb
points(-fitBV$order.by.i.comb$rho, fitBV$order.by.i.comb$n.var/ncol(var.mat),
  pch = 2, col = 4, t = "o", lty = 2)


### biobio
# biological community variables that best correlate with the
# overall biological community
fix.mat = wisconsin(varespec)
var.mat = wisconsin(varespec)
fix.dist.method = "bray"
var.dist.method = "bray"
scale.fix = FALSE
scale.var = FALSE
p.feat <- 0.1

# mantelNSGA2
set.seed(1111)
fitGA <- mantelNSGA2(
  fix.mat = fix.mat, var.mat = var.mat,
  fix.dist.method = fix.dist.method, var.dist.method = var.dist.method,
  scale.fix = scale.fix, scale.var = scale.var, p.feat = p.feat,
  pop.size = 50, max.iter = 100, stop.criterion = 50,
  mutation.rate = 0.2, crossover.rate = 0.8
)
plot(fitGA$generation.fitness)
fitGA$pareto.solution
plot(fitGA, parFrontT = "o")


# Compare to bvStep
set.seed(1111)
fitBV <- bvStep(
  fix.mat = fix.mat, var.mat = var.mat,
  fix.dist.method = fix.dist.method, var.dist.method = var.dist.method,
  scale.fix = scale.fix, scale.var = scale.var,
  num.restarts = 50,
  random.selection = TRUE,
  prop.selected.var = 0.3, var.always.include = c(15,23,26)
)
fitBV$order.by.best # mantelGA not looking in simpler solutions enough
fitBV$order.by.i.comb
points(-fitBV$order.by.i.comb$rho, fitBV$order.by.i.comb$n.var/ncol(var.mat),
  pch = 2, col = 4, t = "o", lty = 2)







}
